package main

import (
	"fmt"
	"time"
)

// Package time provides functionality for measuring and displaying time.
// time 包提供了测量和显示时间的能力

// The calendrical calculations always assume a Gregorian calendar, with
// no leap seconds.
// 日期计算时，使用 Gregorian calendar（公历），并且没有闰秒
// Gregorian calendar：https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86
// 闰秒：https://zh.wikipedia.org/wiki/%E9%97%B0%E7%A7%92

// Monotonic Clocks
// 时间单调增长的时钟（后文翻译将继续使用 monotonic clock 这个英文说法）

// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.Now contains both a wall
// clock reading and a monotonic clock reading; later time-telling
// operations use the wall clock reading, but later time-measuring
// operations, specifically comparisons and subtractions, use the
// monotonic clock reading.
// 操作系统提供了两种 clock：一种是 wall clock，它跟真实世界的时间同步；一种是 monotonic clock，它的时间纯单调递增。
// 通常来讲，wall clock 用于展示时间，monotonic clock 用于计算时间。
// 本 time 包并没有割裂成两套 API，而是通过 time.Now 这一同时包含 wall clock 和 monotonic clock 的方法返回时间。
// time.Now 内部使用 wall clock 来展示时间，使用 monotonic clock 来计算时间，尤其是用于比较时间和计算时间差值。

// For example, this code always computes a positive elapsed time of
// approximately 20 milliseconds, even if the wall clock is changed during
// the operation being timed:
// 举个例子，下面这段代码将计算出大概 20 微秒的时间，即使在计算过程中 wall clock 变化了，算出来的结果也不会变化。

//	start := time.Now()
//	... operation that takes 20 milliseconds ...
//	t := time.Now()
//	elapsed := t.Sub(start)
//
// Other idioms, such as time.Since(start), time.Until(deadline), and
// time.Now().Before(deadline), are similarly robust against wall clock
// resets.
// 还有些类似的 API，比如 time.Since(start)、time.Until(deadline)、time.Now().Before(deadline)，都不会随 wall clock 变化而变化

// The rest of this section gives the precise details of how operations
// use monotonic clocks, but understanding those details is not required
// to use this package.
// 接下来要讲的部分，会讲清楚 time 包使用 monotonic clocks 的细节，但是单纯使用 time 包的话，可以不必知道这些细节。

// The Time returned by time.Now contains a monotonic clock reading.
// If Time t has a monotonic clock reading, t.Add adds the same duration to
// both the wall clock and monotonic clock readings to compute the result.
// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
// computations, they always strip any monotonic clock reading from their results.
// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
// of the wall time, they also strip any monotonic clock reading from their results.
// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
// 使用 time.Now 方法返回的时间对象，内部包含了 monotonic clock 时间。
// 如果一个时间对象 t 内部包含 monotonic clock，那么使用 t.add 方法增加时间时，会同时往 t 的 wall clock 和 monotonic clock 增加这段时间。
// 因为 t.AddDate(y, m, d)、t.Round(d)、t.Truncate(d) 都是在计算 wall time，它们会在结果中删掉 monotonic clock。
// 因为 t.In、t.Local、t.UTC 是用于解释 wall time 的，它们也会在结果中删掉 monotonic clock。
// 删掉 monotonic clock 的规范写法是 t = t.Round(0)。

// If Times t and u both contain monotonic clock readings, the operations
// t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
// using the monotonic clock readings alone, ignoring the wall clock
// readings. If either t or u contains no monotonic clock reading, these
// operations fall back to using the wall clock readings.
// 如果时间对象 t 和 u 都包含 monotonic clock 时间，那么在使用 t.After(u)、t.Before(u)、t.Equal(u)、t.Sub(u) 时，都只会使用 monotonic clock 计算。
// 如果时间对象 t 和 u 只要有一个没有 monotonic clock 时间，那么将使用 wall clock 计算。

// On some systems the monotonic clock will stop if the computer goes to sleep.
// On such a system, t.Sub(u) may not accurately reflect the actual
// time that passed between t and u.
// 有些系统在睡眠时会停止 monotonic clock。在这些系统上，t.Sub(u) 算出的结果不准。

// Because the monotonic clock reading has no meaning outside
// the current process, the serialized forms generated by t.GobEncode,
// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
// clock reading, and t.Format provides no format for it. Similarly, the
// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
// t.UnmarshalJSON, and t.UnmarshalText always create times with
// no monotonic clock reading.
// 因为 monotonic clock 时间在当前进程外没有任何意义，因此 t.GobEncode、t.MarshalBinary、t.MarshalJSON、t.MarshalText 这些序列化方法，将会省略 monotonic clock。
// 同样地，time.Date、time.Parse、time.ParseInLocation、time.Unix 这些构造方法，以及 t.GobDecode、t.UnmarshalBinary、t.UnmarshalJSON、t.UnmarshalText
// 这些反序列化方法，创建出的时间对象也不会包含 monotonic clock 时间。

// Note that the Go == operator compares not just the time instant but
// also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
// documentation for the Time type for a discussion of equality
// testing for Time values.
// 需要注意的是，在 Go 中 == 操作符不光会比较时间戳，也会比较时区和 monotonic clock 时间。
// 跟时间相等相关的部分，参阅 time.Time 类型的介绍。

// For debugging, the result of t.String does include the monotonic
// clock reading if present. If t != u because of different monotonic clock readings,
// that difference will be visible when printing t.String() and u.String().
// 在调试时，如果时间对象 t 内部存在 monotonic clock 时间，t.String 方法会返回该时间。
// 如果两个时间对象 t 和 u 因为 monotonic clock 不同而不同，可以通过 t.String() 和 u.String() 方法显示出来。

func learnTime() {

	// 创建 time.Time 对象
	now := time.Now()
	unix := time.Unix(1639094400, 0)
	date := time.Date(2021, time.December, 10, 0, 0, 0, 0, time.UTC)
	parse, _ := time.Parse("2006-01-02 15:04:05", "2021-12-10 00:00:00")
	fmt.Printf("%v\n%v\n%v\n%v\n", now, unix, date, parse)

	// —————————————— 一些枚举 ——————————————

	// 月份
	months := []time.Month{
		time.January,
		time.February,
		time.March,
		time.April,
		time.May,
		time.June,
		time.July,
		time.August,
		time.September,
		time.October,
		time.November,
		time.December,
	}
	fmt.Printf("%v", months) // 打印：[January February March April May June July August September October November December]

	// 周几
	weekdays := []time.Weekday{
		time.Monday,
		time.Tuesday,
		time.Wednesday,
		time.Thursday,
		time.Friday,
		time.Saturday,
		time.Sunday,
	}
	fmt.Printf("%v", weekdays) // 打印：[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]

	// 持续时间（最大只到小时，避免夏令时造成的时间错乱）
	durations := []time.Duration{
		time.Hour,
		time.Minute,
		time.Second,
		time.Millisecond,
		time.Microsecond,
		time.Nanosecond,
	}
	fmt.Printf("%v", durations) // 打印：[1h0m0s 1m0s 1s 1ms 1µs 1ns]

}

func separate() {
	fmt.Printf("\n\n\n")
}
