package main

import (
	"fmt"
	"time"
)

// Package time provides functionality for measuring and displaying time.
// time 包提供了测量和显示时间的能力

// The calendrical calculations always assume a Gregorian calendar, with
// no leap seconds.
// 日期计算时，使用 Gregorian calendar（公历），并且没有闰秒
// Gregorian calendar：https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86
// 闰秒：https://zh.wikipedia.org/wiki/%E9%97%B0%E7%A7%92

// Monotonic Clocks
// 时间单调增长的时钟（后文翻译将继续使用 monotonic clock 这个英文说法）

// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.Now contains both a wall
// clock reading and a monotonic clock reading; later time-telling
// operations use the wall clock reading, but later time-measuring
// operations, specifically comparisons and subtractions, use the
// monotonic clock reading.
//
// For example, this code always computes a positive elapsed time of
// approximately 20 milliseconds, even if the wall clock is changed during
// the operation being timed:
//
//	start := time.Now()
//	... operation that takes 20 milliseconds ...
//	t := time.Now()
//	elapsed := t.Sub(start)
//
// Other idioms, such as time.Since(start), time.Until(deadline), and
// time.Now().Before(deadline), are similarly robust against wall clock
// resets.
//
// The rest of this section gives the precise details of how operations
// use monotonic clocks, but understanding those details is not required
// to use this package.
//
// The Time returned by time.Now contains a monotonic clock reading.
// If Time t has a monotonic clock reading, t.Add adds the same duration to
// both the wall clock and monotonic clock readings to compute the result.
// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
// computations, they always strip any monotonic clock reading from their results.
// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
// of the wall time, they also strip any monotonic clock reading from their results.
// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
//
// If Times t and u both contain monotonic clock readings, the operations
// t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
// using the monotonic clock readings alone, ignoring the wall clock
// readings. If either t or u contains no monotonic clock reading, these
// operations fall back to using the wall clock readings.
//
// On some systems the monotonic clock will stop if the computer goes to sleep.
// On such a system, t.Sub(u) may not accurately reflect the actual
// time that passed between t and u.
//
// Because the monotonic clock reading has no meaning outside
// the current process, the serialized forms generated by t.GobEncode,
// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
// clock reading, and t.Format provides no format for it. Similarly, the
// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
// t.UnmarshalJSON, and t.UnmarshalText always create times with
// no monotonic clock reading.
//
// Note that the Go == operator compares not just the time instant but
// also the Location and the monotonic clock reading. See the
// documentation for the Time type for a discussion of equality
// testing for Time values.
//
// For debugging, the result of t.String does include the monotonic
// clock reading if present. If t != u because of different monotonic clock readings,
// that difference will be visible when printing t.String() and u.String().
//

func learnTime() {

	// 创建 time.Time 对象
	now := time.Now()
	unix := time.Unix(1639094400, 0)
	date := time.Date(2021, time.December, 10, 0, 0, 0, 0, time.UTC)
	parse, _ := time.Parse("2006-01-02 15:04:05", "2021-12-10 00:00:00")
	fmt.Printf("%v\n%v\n%v\n%v\n", now, unix, date, parse)

	// —————————————— 一些枚举 ——————————————

	// 月份
	months := []time.Month{
		time.January,
		time.February,
		time.March,
		time.April,
		time.May,
		time.June,
		time.July,
		time.August,
		time.September,
		time.October,
		time.November,
		time.December,
	}
	fmt.Printf("%v", months) // 打印：[January February March April May June July August September October November December]

	// 周几
	weekdays := []time.Weekday{
		time.Monday,
		time.Tuesday,
		time.Wednesday,
		time.Thursday,
		time.Friday,
		time.Saturday,
		time.Sunday,
	}
	fmt.Printf("%v", weekdays) // 打印：[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]

	// 持续时间（最大只到小时，避免夏令时造成的时间错乱）
	durations := []time.Duration{
		time.Hour,
		time.Minute,
		time.Second,
		time.Millisecond,
		time.Microsecond,
		time.Nanosecond,
	}
	fmt.Printf("%v", durations) // 打印：[1h0m0s 1m0s 1s 1ms 1µs 1ns]

}

func separate() {
	fmt.Printf("\n\n\n")
}
