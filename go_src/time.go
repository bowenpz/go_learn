package main

import (
	"fmt"
	"time"
)

// —————————————————————————————————————————————
// —————————————— 翻译：time 包注释 ——————————————
// —————————————————————————————————————————————

// Package time provides functionality for measuring and displaying time.
// time 包提供了测量和显示时间的能力

// The calendrical calculations always assume a Gregorian calendar, with
// no leap seconds.
// 日期计算时，使用 Gregorian calendar（公历），并且没有闰秒
// Gregorian calendar：https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86
// 闰秒：https://zh.wikipedia.org/wiki/%E9%97%B0%E7%A7%92

// Monotonic Clocks
// 时间单调增长的时钟（后文翻译将继续使用 monotonic clock 这个英文说法）

// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.Now contains both a wall
// clock reading and a monotonic clock reading; later time-telling
// operations use the wall clock reading, but later time-measuring
// operations, specifically comparisons and subtractions, use the
// monotonic clock reading.
// 操作系统提供了两种 clock：一种是 wall clock，它跟真实世界的时间同步；一种是 monotonic clock，它的时间纯单调递增。
// 通常来讲，wall clock 用于展示时间，monotonic clock 用于计算时间。
// 本 time 包并没有割裂成两套 API，而是通过 time.Now 这一同时包含 wall clock 和 monotonic clock 的方法返回时间。
// time.Now 内部使用 wall clock 来展示时间，使用 monotonic clock 来计算时间，尤其是用于比较时间和计算时间差值。

// For example, this code always computes a positive elapsed time of
// approximately 20 milliseconds, even if the wall clock is changed during
// the operation being timed:
// 举个例子，下面这段代码将计算出大概 20 微秒的时间，即使在计算过程中 wall clock 变化了，算出来的结果也不会变化。

//	start := time.Now()
//	... operation that takes 20 milliseconds ...
//	t := time.Now()
//	elapsed := t.Sub(start)
//
// Other idioms, such as time.Since(start), time.Until(deadline), and
// time.Now().Before(deadline), are similarly robust against wall clock
// resets.
// 还有些类似的 API，比如 time.Since(start)、time.Until(deadline)、time.Now().Before(deadline)，都不会随 wall clock 变化而变化

// The rest of this section gives the precise details of how operations
// use monotonic clocks, but understanding those details is not required
// to use this package.
// 接下来要讲的部分，会讲清楚 time 包使用 monotonic clocks 的细节，但是单纯使用 time 包的话，可以不必知道这些细节。

// The Time returned by time.Now contains a monotonic clock reading.
// If Time t has a monotonic clock reading, t.Add adds the same duration to
// both the wall clock and monotonic clock readings to compute the result.
// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
// computations, they always strip any monotonic clock reading from their results.
// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
// of the wall time, they also strip any monotonic clock reading from their results.
// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
// 使用 time.Now 方法返回的时间对象，内部包含了 monotonic clock 时间。
// 如果一个时间对象 t 内部包含 monotonic clock，那么使用 t.add 方法增加时间时，会同时往 t 的 wall clock 和 monotonic clock 增加这段时间。
// 因为 t.AddDate(y, m, d)、t.Round(d)、t.Truncate(d) 都是在计算 wall time，它们会在结果中删掉 monotonic clock。
// 因为 t.In、t.Local、t.UTC 是用于解释 wall time 的，它们也会在结果中删掉 monotonic clock。
// 删掉 monotonic clock 的规范写法是 t = t.Round(0)。

// If Times t and u both contain monotonic clock readings, the operations
// t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
// using the monotonic clock readings alone, ignoring the wall clock
// readings. If either t or u contains no monotonic clock reading, these
// operations fall back to using the wall clock readings.
// 如果时间对象 t 和 u 都包含 monotonic clock 时间，那么在使用 t.After(u)、t.Before(u)、t.Equal(u)、t.Sub(u) 时，都只会使用 monotonic clock 计算。
// 如果时间对象 t 和 u 只要有一个没有 monotonic clock 时间，那么将使用 wall clock 计算。

// On some systems the monotonic clock will stop if the computer goes to sleep.
// On such a system, t.Sub(u) may not accurately reflect the actual
// time that passed between t and u.
// 有些系统在睡眠时会停止 monotonic clock。在这些系统上，t.Sub(u) 算出的结果不准。

// Because the monotonic clock reading has no meaning outside
// the current process, the serialized forms generated by t.GobEncode,
// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
// clock reading, and t.Format provides no format for it. Similarly, the
// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
// t.UnmarshalJSON, and t.UnmarshalText always create times with
// no monotonic clock reading.
// 因为 monotonic clock 时间在当前进程外没有任何意义，因此 t.GobEncode、t.MarshalBinary、t.MarshalJSON、t.MarshalText 这些序列化方法，将会省略 monotonic clock。
// 同样地，time.Date、time.Parse、time.ParseInLocation、time.Unix 这些构造方法，以及 t.GobDecode、t.UnmarshalBinary、t.UnmarshalJSON、t.UnmarshalText
// 这些反序列化方法，创建出的时间对象也不会包含 monotonic clock 时间。

// Note that the Go == operator compares not just the time instant but
// also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
// documentation for the Time type for a discussion of equality
// testing for Time values.
// 需要注意的是，在 Go 中 == 操作符不光会比较时间戳，也会比较时区和 monotonic clock 时间。
// 跟时间相等相关的部分，参阅 time.Time 类型的介绍。

// For debugging, the result of t.String does include the monotonic
// clock reading if present. If t != u because of different monotonic clock readings,
// that difference will be visible when printing t.String() and u.String().
// 在调试时，如果时间对象 t 内部存在 monotonic clock 时间，t.String 方法会返回该时间。
// 如果两个时间对象 t 和 u 因为 monotonic clock 不同而不同，可以通过 t.String() 和 u.String() 方法显示出来。

// ——————————————————————————————————————————————————
// —————————————— 翻译：time.Time 类注释 ——————————————
// ——————————————————————————————————————————————————

// A Time represents an instant in time with nanosecond precision.
// time.Time 类代表着一个精度到纳秒的时间戳（time instant）。

// Programs using times should typically store and pass them as values,
// not pointers. That is, time variables and struct fields should be of
// type time.Time, not *time.Time.
// 程序在存储和传递时间对象时，应该使用值类型，而非指针类型。
// 因此，在使用 time 变量和结构体时，应当使用 time.Time，而非 *time.Time。

// A Time value can be used by multiple goroutines simultaneously except
// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
// UnmarshalText are not concurrency-safe.
// time.Time 对象在多 goroutine 环境下，除了 GobDecode、UnmarshalBinary、UnmarshalJSON 和 UnmarshalText 这四个方法下不是并发安全之外，其余都并发安全。

// Time instants can be compared using the Before, After, and Equal methods.
// The Sub method subtracts two instants, producing a Duration.
// The Add method adds a Time and a Duration, producing a Time.
// 时间戳可以使用 Before、After、Equal 方法进行比较。
// Sub 方法对两个 time.Time 相减，得到一个 time.Duration。
// Add 方法把 time.Time 和 time.Duration 相加，得到一个 time.Time。

// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
// As this time is unlikely to come up in practice, the IsZero method gives
// a simple way of detecting a time that has not been initialized explicitly.
// time.Time 的零值是公元 1 年 1 月 1 日，00:00:00.000000000 UTC。
// 由于这个时间在实际场景中不太可能出现，因此提供 IsZero 方法检测 time.Time 对象是否被显式初始化。

// Each Time has associated with it a Location, consulted when computing the
// presentation form of the time, such as in the Format, Hour, and Year methods.
// The methods Local, UTC, and In return a Time with a specific location.
// Changing the location in this way changes only the presentation; it does not
// change the instant in time being denoted and therefore does not affect the
// computations described in earlier paragraphs.
// 每一个 time.Time 对象会关联时区（Location）信息，用于表示时间格式，例如在 Format、Hour、Year 方法中会使用。
// Local、UTC、In 方法会返回一个包含指定时区的 time.Time 对象。
// 以这些方法修改时区，只会修改时间显示，不会修改时间戳，也不会影响之前已有的时间。

// Representations of a Time value saved by the GobEncode, MarshalBinary,
// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
// the location name. They therefore lose information about Daylight Saving Time.
// 使用 GobEncode、MarshalBinary、MarshalJSON 和 MarshalText 方法存储时间，只会包含时区偏移量（Time.Location's offset），不会存储时区名称。
// 因此这些方法会丢失夏令时信息。

// In addition to the required “wall clock” reading, a Time may contain an optional
// reading of the current process's monotonic clock, to provide additional precision
// for comparison or subtraction.
// See the “Monotonic Clocks” section in the package documentation for details.
// time.Time 除了包含必需的 wall clock 之外，还可能会包含当前程序的 monotonic clock，用于精确地比较时间、计算时间差值。
// 有关 monotonic clock 的部分可以阅读 time 包的文档。

// Note that the Go == operator compares not just the time instant but also the
// Location and the monotonic clock reading. Therefore, Time values should not
// be used as map or database keys without first guaranteeing that the identical Location has been set for all values
// identical Location has been set for all values, which can be achieved
// through use of the UTC or Local method, and that the monotonic clock reading
// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
// to t == u, since t.Equal uses the most accurate comparison available and
// correctly handles the case when only one of its arguments has a monotonic
// clock reading.
// 需要注意的是，在 Go 中 == 操作符不光会比较时间戳，也会比较时区和 monotonic clock 时间。
// 因此，如果没有使用 UTC 或 Local 方法确保时区相同，或者没有使用 t.Round(0) 去除掉 monotonic clock 时间，不应该使用 time.Time 作为 map 或数据库的 key。
// 通常情况下，优先使用 t.Equal(u)，而不是 t == u，因为 t.Equal 方法更精确，并且能正确处理单 monotonic clock 的 case。

func learnTime() {

	// 创建 time.Time 对象
	now := time.Now()
	unix := time.Unix(1639094400, 0)
	date := time.Date(2021, time.December, 10, 0, 0, 0, 0, time.UTC)
	parse, _ := time.Parse("2006-01-02 15:04:05", "2021-12-10 00:00:00")
	fmt.Printf("%v\n%v\n%v\n%v\n", now, unix, date, parse)

	// —————————————— 一些枚举 ——————————————

	// 月份
	months := []time.Month{
		time.January,
		time.February,
		time.March,
		time.April,
		time.May,
		time.June,
		time.July,
		time.August,
		time.September,
		time.October,
		time.November,
		time.December,
	}
	fmt.Printf("%v", months) // 打印：[January February March April May June July August September October November December]

	// 周几
	weekdays := []time.Weekday{
		time.Monday,
		time.Tuesday,
		time.Wednesday,
		time.Thursday,
		time.Friday,
		time.Saturday,
		time.Sunday,
	}
	fmt.Printf("%v", weekdays) // 打印：[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]

	// 持续时间（最大只到小时，避免夏令时造成的时间错乱）
	durations := []time.Duration{
		time.Hour,
		time.Minute,
		time.Second,
		time.Millisecond,
		time.Microsecond,
		time.Nanosecond,
	}
	fmt.Printf("%v", durations) // 打印：[1h0m0s 1m0s 1s 1ms 1µs 1ns]

}

func separate() {
	fmt.Printf("\n\n\n")
}
